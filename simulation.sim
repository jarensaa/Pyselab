begin
  external class demos="./demos.atr";
  demos
  begin

    real  METER_TO_BASE_STATION_PACKETLOSS_PROBABILITY,
          METER_TO_BASE_STATION_TIME_DELAY,
          SERVER_FAILURE_INTENSITY,
          CONTROLLER_FAILURE_INTENSITY;


    ref(RDist)    timeBetweenPacketsFromMeter_,
                  delayFromBaseStationToController_,
                  dataProcessingTimeInController_,
                  dataProcessingTimeInServer_,
                  serverRestartTime_,
                  serverSwitchoverTime_,
                  controllerRestartTime_,
                  randomNumberGenerator_;

    ref(Res)      controller_;

    ref(WaitQ)    ServerQueue1_;

    ref(Tally)  totalTransferTime_,
                measuredDelayFromMeterToBaseStation_;

    ref(Count)  lostPackets_,
                recievedPackets_;

    !declare the simulation logging variables;
    integer sentPackets,  droppedPackets, packetNumber;



    Entity class SmartMeter;
    begin
      real time;
      !smart meter events goes here;
      loop:
        time := timeBetweenPacketsFromMeter_.sample;
        hold(time);
        measuredDelayFromMeterToBaseStation_.update(time);
        new Packet("packet").schedule(now);
        repeat;
    end;

    Entity class Packet;
    begin

      !Set timestamp for packet generation;
      long real timestamp;
      timestamp := time;

      !packet goes from meter to BS, check for packet loss;
      hold(METER_TO_BASE_STATION_TIME_DELAY);

      if randomNumberGenerator_.sample <= METER_TO_BASE_STATION_PACKETLOSS_PROBABILITY then begin
        lostPackets_.update(1);
        goto disconnection;
      end;


      totalTransferTime_.update(METER_TO_BASE_STATION_TIME_DELAY);

      !packet is sent from BS to Controller;
      hold(delayFromBaseStationToController_.sample);

      !packet is queued in controller;

      controller_.acquire(1);
      hold(dataProcessingTimeInController_.sample);
      controller_.release(1);

      !packet is sent to Server;
      ServerQueue1_.wait;

      !log cool data;
      totalTransferTime_.update(time-timestamp);
      recievedPackets_.update(1);


      disconnection:
        !do nothing;


    end;

    Entity class Server(ServerQueue_);
    ref(WaitQ) ServerQueue_;
    begin
      ref(Packet) packet_;

      loop:
        packet_ :- ServerQueue_.coopt;
          hold(dataProcessingTimeInServer_.sample);
        packet_.schedule(now);

    end;


    !Initiate all the variables/constants/tallys and stuff.
    Then, make som objects,
    Then, run the program;

    METER_TO_BASE_STATION_TIME_DELAY := 0.110;
    METER_TO_BASE_STATION_PACKETLOSS_PROBABILITY := 0.05;


    timeBetweenPacketsFromMeter_ :- new NegExp("Meter-BS-delay",2);
    randomNumberGenerator_ :- new Uniform("numbergenerator",0,1);
    delayFromBaseStationToController_ :- new NegExp("BS-Controler",1/0.02);
    dataProcessingTimeInController_ :- new NegExp("controller",1/0.0001);
    dataProcessingTimeInServer_ :- new NegExp("server",1/0.002);

    ServerQueue1_ :- new WaitQ("server1");

    controller_ :- new Res("controller",1);

    measuredDelayFromMeterToBaseStation_ :- new Tally("meterdelay");
    totalTransferTime_ :- new Tally("totalTime");

    lostPackets_ :- new Count("lostPackets");
    recievedPackets_ :- new Count("recieved");

    new Server("server1",ServerQueue1_);
    new SmartMeter("Meter 1").schedule(0);
    hold(300);


  end;
end;
