begin
  external class demos="./demos.atr";
  demos
  begin

    real          METER_TO_BASE_STATION_PACKETLOSS_PROBABILITY,
                  METER_TO_BASE_STATION_TIME_DELAY,
                  AVARAGE_BASE_STATION_TO_CONTROLLER_DELAY,
                  AVARAGE_CONTROLLER_PROCESSING_TIME,
                  AVARAGE_SERVER_PROCESSING_TIME,
                  PACKETS_PER_SECOND_FROM_METER,
                  NUMBER_OF_METERS,
                  SERVER_FAILURE_INTENSITY,
                  SERVER_RESTART_TIME,
                  SERVER_SWITCHOVER_TIME,
                  CONTROLLER_FAILURE_INTENSITY,
                  CONTROLLER_RESTART_TIME,
                  NUMBER_OF_ACTIVE_SERVER_SLOTS,
                  NUMBER_OF_TOTAL_SERVERS,
                  PACKETS_TO_SIMULATE,
                  SIMULATION_TIME,
                  elhubDowntime,
                  serverDownTime,
                  controllerDownTime;

    ref(RDist)    delayFromBaseStationToController_,
                  dataProcessingTimeInController_,
                  dataProcessingTimeInServer_,
                  randomNumberGenerator_,
                  timeBetweenPacketsFromMeter_,
                  serverRestartTime_,
                  serverSwitchoverTime_,
                  controllerRestartTime_;

    ref(Res)      controller_,
                  activeServer_;

    ref(Bin)	    runtimeBin_;

    ref(WaitQ)    ServerQueue_;

    ref(CondQ)    elhubMonitor_,
                  serverMonitor_,
                  controllerMonitor_;

    ref(Tally)    totalTransferTime_,
                  elhubDownTime_,
                  serverDownTime_,
                  controllerDownTime_;

    ref(Count)    lostPackets_,
                  recievedPackets_,
                  fastEnoughPackets_,
                  tooSlowPackets_,
                  testCounter_,
                  serverRestarts_,
                  serverCount1_,
                  serverCount2_,
                  serverCount3_,
                  elhubDowntimeCount_,
                  serverDownTimeCount_,
                  controllerDownTimeCount_;

    integer       numberOfAvailableActiveServerSlots,
                  numberOfActiveServers;

    boolean       controllerIsBroken;

    Entity class SmartMeter;
    begin
      real time;
      !smart meter events goes here;
      loop:
        time := timeBetweenPacketsFromMeter_.sample;
        hold(time);
        new Packet("packet").schedule(now);
        repeat;
    end;


    Entity class Packet;
    begin
      !Set timestamp for packet generation;
      long real timestamp;
      timestamp := time;

      priority := 1;

      !packet goes from meter to BS, check for packet loss;
      hold(METER_TO_BASE_STATION_TIME_DELAY);

      if randomNumberGenerator_.sample <= METER_TO_BASE_STATION_PACKETLOSS_PROBABILITY then begin
        lostPackets_.update(1);
        goto disconnection;
      end;

      !packet is sent from BS to Controller;
      hold(delayFromBaseStationToController_.sample);

      !packet is queued in controller;

      controller_.acquire(1);
      hold(dataProcessingTimeInController_.sample);
      controller_.release(1);

      ServerQueue_.wait;

      totalTransferTime_.update(time-timestamp);
      recievedPackets_.update(1);
      if time-timestamp < 0.2 then fastEnoughPackets_.update(1)
      else tooSlowPackets_.update(1);

      disconnection:
      	runtimeBin_.give(1);
    end;


    Entity class Server(ServerCount_);
    ref(Count) ServerCount_;
    begin
      ref(Packet) packet_;
      ref(ServerFailure) serverFailure_;

      serverFailure_ :- new ServerFailure("failure",this Server);
      serverFailure_.schedule(now);


      passiveActiveSwitch:
        if numberOfAvailableActiveServerSlots = 0 and interrupted = 0 then hold(SIMULATION_TIME);
          if interrupted>0 then
            begin
              goto broken;
            end;

          numberOfAvailableActiveServerSlots := numberOfAvailableActiveServerSlots - 1;

          hold(serverSwitchoverTime_.sample);
          numberOfActiveServers := numberOfActiveServers + 1;
          serverMonitor_.signal;

      active:
        loop:

          if ServerQueue_.LENGTH = 0 and interrupted = 0 then hold(SIMULATION_TIME);

          if interrupted>0 then
          begin
            numberOfAvailableActiveServerSlots := numberOfAvailableActiveServerSlots + 1;
            numberOfActiveServers := numberOfActiveServers - 1;
            goto broken;
          end;

          ServerCount_.update(1);
          packet_ :- ServerQueue_.coopt;
          hold(dataProcessingTimeInServer_.sample);
          packet_.schedule(now);
          repeat;

      broken:
        serverMonitor_.signal;
        if interrupted>0 then hold(SIMULATION_TIME);
        serverRestarts_.update(1);
        goto passiveActiveSwitch;

    end;

    ! *******************************************************
      ********************** FAILURES ***********************
      ******************************************************* ;

    Entity class ServerFailure(server_);
    ref(Server) server_;
    begin
      priority := 3;
      loop:
        hold(1/SERVER_FAILURE_INTENSITY);

        server_.interrupt(1);

        hold(serverRestartTime_.sample);

        server_.interrupt(0);

        repeat;
    end;

    Entity class ControllerFailure();
    begin
      loop:
        hold(1/CONTROLLER_FAILURE_INTENSITY);

        controller_.acquire(1);
        controllerIsBroken := true;
        controllerMonitor_.signal;

        hold(controllerRestartTime_.sample);

        controllerIsBroken := false;
        controller_.release(1);
        controllerMonitor_.signal;

        repeat;
    end;


    ! *******************************************************
      ********************** MONITORS ***********************
      ******************************************************* ;

    Entity class ELHUBmonitor;
    begin
      long real elhubTimestamp;
      loop:
        elhubMonitor_.waituntil(controllerIsBroken or numberOfAvailableActiveServerSlots >= NUMBER_OF_ACTIVE_SERVER_SLOTS);
        elhubtimestamp := time;

        elhubMonitor_.waituntil(not controllerIsBroken and numberOfAvailableActiveServerSlots < NUMBER_OF_ACTIVE_SERVER_SLOTS);

        elhubDowntime := elhubdowntime + (time - elhubtimestamp);
        elhubDowntimeCount_.update(1);
        elhubDownTime_.update(time-elhubtimestamp);

        repeat;
    end;

    Entity class Servermonitor;
    begin
      long real serverTimestamp;
      loop:
        serverMonitor_.waituntil(numberOfActiveServers = 0);
        serverTimestamp := time;
        elhubMonitor_.signal;

        serverMonitor_.waituntil(numberOfActiveServers > 0);

        serverDownTime := serverDownTime + (time - serverTimestamp);
        serverDownTimeCount_.update(1);
        serverDownTime_.update(time-serverTimestamp);
        elhubMonitor_.signal;

        repeat;
    end;

    Entity class ControllerMonitor;
    begin
      long real controllerTimestamp;
      loop:
        controllerMonitor_.waituntil(controllerIsBroken);
        controllerTimestamp := time;
        elhubMonitor_.signal;

        controllerMonitor_.waituntil(not controllerIsBroken);

        controllerDownTime := controllerDownTime + (time - controllerTimestamp);
        controllerDownTimeCount_.update(1);
        controllerDownTime_.update(time-controllerTimestamp);
        elhubMonitor_.signal;

        repeat;
    end;


    ! *******************************************************
      ********************** CONSTANTS **********************
      ******************************************************* ;

    METER_TO_BASE_STATION_PACKETLOSS_PROBABILITY := 0.05;
    METER_TO_BASE_STATION_TIME_DELAY := 0.110;
    AVARAGE_BASE_STATION_TO_CONTROLLER_DELAY := 0.02;
    AVARAGE_CONTROLLER_PROCESSING_TIME := 0.0001;
    AVARAGE_SERVER_PROCESSING_TIME := 0.002;

    SERVER_FAILURE_INTENSITY := 10;
    CONTROLLER_FAILURE_INTENSITY := 10;
    SERVER_RESTART_TIME := 0.001;
    SERVER_SWITCHOVER_TIME := 0.0002;
    CONTROLLER_RESTART_TIME := 0.0005;

    NUMBER_OF_ACTIVE_SERVER_SLOTS := 2;
    NUMBER_OF_TOTAL_SERVERS := 2;

    PACKETS_PER_SECOND_FROM_METER := 0.1;
    NUMBER_OF_METERS := 1000;
    PACKETS_TO_SIMULATE := 10000;
    SIMULATION_TIME := 1000;


    ! *******************************************************
      ********************** VARIABLES **********************
      ******************************************************* ;

    elhubDowntime       := 0;
    serverDownTime      := 0;
    controllerDownTime  := 0;
    numberOfActiveServers := 0;
    numberOfAvailableActiveServerSlots := 2;

    controllerIsBroken := false;


    ! *******************************************************
      ******************** OBJECT INTS **********************
      ******************************************************* ;

    timeBetweenPacketsFromMeter_ :- new NegExp("metertime",PACKETS_PER_SECOND_FROM_METER * NUMBER_OF_METERS);
    randomNumberGenerator_ :- new Uniform("numbergenerator",0,1);
    delayFromBaseStationToController_ :- new NegExp("BS-Controler",1/AVARAGE_BASE_STATION_TO_CONTROLLER_DELAY);
    dataProcessingTimeInController_ :- new NegExp("controller",1/AVARAGE_CONTROLLER_PROCESSING_TIME);
    dataProcessingTimeInServer_ :- new NegExp("server",1/AVARAGE_SERVER_PROCESSING_TIME);

    serverRestartTime_ :- new NegExp("serverRestart",1/SERVER_RESTART_TIME);
    serverSwitchoverTime_ :- new NegExp("serverSwitchover",1/SERVER_SWITCHOVER_TIME);
    controllerRestartTime_ :- new NegExp("controllerRestart",1/CONTROLLER_RESTART_TIME);

    ServerQueue_ :- new WaitQ("ServerQueue");

    elhubMonitor_       :- new CondQ("elhubCondQ");
    serverMonitor_      :- new CondQ("serverCondQ");
    controllerMonitor_  :- new CondQ("contrCondQ");

    lostPackets_ :-             new Count("lostPackets");
    recievedPackets_ :-         new Count("recieved");
    fastEnoughPackets_ :-       new Count("fast packets");
    tooSlowPackets_ :-          new Count("slow packets");
    serverRestarts_ :-          new Count("broken");
    serverCount1_   :-          new Count("server1");
    serverCount2_   :-          new Count("server2");
    serverCount3_   :-          new Count("server3");
    elhubDowntimeCount_ :-      new Count("elhubdown");
    serverDownTimeCount_:-      new Count("serverDown");
    controllerDownTimeCount_ :- new Count("controllerDown");

    totalTransferTime_ :- new Tally("totalTime");
    elhubDownTime_     :- new Tally("elhubDown");
    serverDownTime_    :- new Tally("serverDown");
    controllerDownTime_:- new Tally("controllerDown");

    runtimeBin_ :-   new Bin("runtimeBin", 0);

    controller_ :-   new Res("controller",1);
    activeServer_ :- new Res("activeServer",NUMBER_OF_ACTIVE_SERVER_SLOTS);

    ! *******************************************************
      ******************* MAIN PROGRAM **********************
      ******************************************************* ;

    new Server("server1",serverCount1_).schedule(0);
    new Server("server2",serverCount2_).schedule(1/(3*SERVER_FAILURE_INTENSITY));
    new Server("server3",serverCount3_).schedule(2/(3*SERVER_FAILURE_INTENSITY));

    new ControllerFailure("controllerFailure").schedule(0);

    new ELHUBmonitor("monitor").schedule(0);
    new Servermonitor("server").schedule(0);
    new ControllerMonitor("controller").schedule(0);

    new SmartMeter("Meter 1").schedule(0);

    hold(SIMULATION_TIME);


    ! *******************************************************
      ************************ OUTPUT ***********************
      ******************************************************* ;

    outtext("elhub  unavailability:       "); outreal(elhubDowntime/SIMULATION_TIME,3,10); outimage;
    outtext("server  unavailability:      "); outreal(serverDownTime/SIMULATION_TIME,3,10); outimage;
    outtext("controller  unavailability:  "); outreal(controllerDowntime/SIMULATION_TIME,3,10); outimage;



  end;
end;
